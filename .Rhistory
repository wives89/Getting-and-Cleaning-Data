install.packages("rstudio")
install.packages("swirl")
library("swirl")
swirl()
true == true
TRUE == TRUE
FALSE = TRUE
FALSE == TRUE
(FALSE == TRUE) == FALSE
6 == 7
6 < 7
6 <=7
10 <= 10
5 != 7
5 != 7
! 5 == 7
FALSE & FALSE
TRUE & c(TRUE, FALSE, TRUE)
TRUE & c(TRUE, FALSE, FALSE)
TRUE && c(TRUE, FALSE, FALSE)
TRUE | c(TRUE, FALSE, FALSE)
TRUE || c(TRUE, FALSE, FALSE)
5>8 || 6 !=8 && 4> 3.9
6>4
istrue(6>4)
isTRUE(6>4)
identical("twins","twins")
xor(5==6, !FALSE)
ints <- sample(10)
ints
ints > 5
which(ints>7)
any(ints <0)
all(ints >0)
sys.date()
Sts.Date
Sts.Date()
Sys.Date()
mean(c(2,4,5))
submit()
boring_funtion('My first function!')
boring_function('My first function!')
boring_function
mean
submit()
submit()
submit()
submit()
my_mean <- function(my_vector) {
sum(my_vector)/length(my_vector)
}
my_vector <- (c(1,4,5))
my_mean(my_vector)
submit()
my_mean(c(4,5,10))
submit()
remainder(5)
remainder(11,5)
remainder(num = 5, divisor = 11)
remainder( 4, div=2)
args(remainder)
submit()
evaluate(sd,c(1.4,3.6,7.9,8.8))
evaluate(function(x){x+1},6)
evaluate(function(x){x[1]},c(8,4,0))
evaluate(function(x){x[length(x)]},c(8,4,0))
?paste
paste("Programming","is","fun")
paste("Programming","is","fun!")
sumbit()
submit()
telegram("your engines", "or you will")
submit()
function(place = "hell", adjective "hot", noun = "garbage")
function(place = "hell", adjective = "hot", noun = "garbage")
mad_libs(place = "hell", adjective "hot", noun = "garbage")
mad_libs(place = "hell", adjective "hot", noun = "garbage")
mad_libs(place = "hell", adjective = "hot", noun = "garbage")
submit()
submit()
'I' %p% 'love' %p% 'R!'
## so when repetedly calling the inverse of a matrix we can refer to these
?solve
f <- function(x) {
f <- function(x) {
f <- function(x) {
x ^ 2
}
f(x) + 1
}
f(x) * 2
}
f(10)
c <- 10
c(c = c)
(c=c)
c
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
x <- c(1:5)
set(x)
makeVector(x)
makeVector(x)
x <- is.numeric(x)
x <- 1:5
x+.1
x<- x+.1
makeVector(x)
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
makeVector(x)
View(f)
m <- NULL
setmean <- function(mean) m <--mean
setmean(x)
m
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
test <- 1:5
makeVector(test)
cachemean(test)
findglobalbs(makeVector)
findglobals(makeVector)
findGlobals(makeVector)
codetools::findGlobals(makeVector)
numeric()
?numeric()
numeric(test)
numeric(length = 5, test)
numeric(length = 5, x = test)
numeric(5)
numeric(5,5)
test = numeric()
test
whatisnumeric <- function( x = numeric()) { x}
z <- whatisnumeric(4)
z
z <- whatisnumeric(4:6)
z
z <- "a"
whatisnumeric(z)
x <- 1:15
z <- makeVector(x)
z
z$setmean()
z$setmean(x)
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}
A <- matrix(c(1,0,4,1,3,4,4,1,0),nrow = 3, ncol = 3)
A
solve(A)
a <- A
solve(a)
makeCacheMatrix(a)
z <- makeCacheMatrix(a)
a
z
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data,...)
x$setmean(m)
m
}
cacheSolve(z)
makeCacheMatrix(a)
z <- makeCacheMatrix(a)
cacheSolve(z)
cacheSolve(x,z)
cacheSolve(z)
cachemean(x)
b <- makeVector(x)
cachemean(b)
## These functions are to store the inverse of a matrix in the cache
## so when repetedly calling the inverse of a matrix we can refer to these
## functions instead of re-calculating.
## this function creates the inverse matrix in the cache
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data,...)
x$setinverse(m)
m
}
makeCacheMatrix(a)
z<- makeCacheMatrix(a)
cacheSolve(z)
x <- rep(0:1, each = 5)
rep?
()
?rep()
x
set.seed(1)
rpois(5,2)
swirl()
?swirl
library(swirl)
swirl()
1
swirl()
ls()
class(plants)
dim(plants)
nrow(plants)
ncol(plants)
object.size(plants)
names(plants)
head(plants)
head(plants,10)
tail(plants,15)
summary(plants)
table(plants$Active_Growth_Period)
str(plants)
?sample
sample(1:6, 4, replace = TRUE)
sample(1:6, 4, replace = TRUE)
sample(1:20, 10)
LETTERS
sample(LETTERS,26)
sample(LETTERS)
sample(c(0,1),100,TRUE,prob = c(.3,.7))
flips <- sample(c(0,1),100,TRUE,prob = c(.3,.7))
flips
sum(flips)
?rbinom
rbinom(1, size = 100, prob =.7)
flips2 <- rbinom(1, size = 100, prob =.7)
flips2 <- rbinom(100, size = 1, prob =.7)
flips2
sum(flips2)
?rnorm
rnorm(10)
rnorm(10,mean = 100, sd = 25)
?rpois
rpois(5,mean=10)
rpois(5,10)
replicate(100, rpois(5,10))
my_pois <- replicate(100, rpois(5,10))
my_pois
cm <- colMeans(my_pois)
hist(cm)
data(cars)
?cars
head(cars)
str(cars)
plot(cars)
?plot
?plot
plot(x = cars$speet, y=cars$dist)
plot(x = cars$speet, y=cars$distance)
plot(x = cars$speed, y=cars$distance)
plot(x = cars$speed, y=cars$dist)
plot(y = cars$speed, x=cars$dist)
plot(x = cars$speed, y=cars$distance)
plot(x = cars$speed, y=cars$dist)
plot(x = cars$speed, y=cars$dist, xlab = "Speed")
plot(x = cars$speed, y=cars$dist, xlab = "Speed", ylab = "Stopping Distance")
plot(x = cars$speed, y=cars$dist, ylab = "Stopping Distance")
plot(x = cars$speed, y=cars$dist, xlab = "Speed", ylab = "Stopping Distance")
plot(x = cars$speed, y=cars$dist, xlab = "Speed", ylab = "Stopping Distance", main = "My Plot")
plot(cars, main = "My Plot")
plot(cars, sub = "My Plot")
plot(cars, sub = "My Plot Subtitle\")
plot(cars, sub = "My Plot Subtitle")
plot(cars, sub = "My Plot Subtitle")
?par
plot(cars, bg = red)
plot(cars, bg = RED)
plot(cars, bg = "red")
plot(cars, col = 2)
plot(cars, xlim = c(10,15))
plot(cars, pch = 2)
data(mtcars)
str(mtcars)
?boxplot
boxplot( mpg ~ cyl)
boxplot(formula = mpg ~ cyl)
boxplot(formula = mtcars$mpg ~ mtcars$cyl)
boxplot(formula = mpg ~ cyl, data = mtcars)
hist(mtcars$mpg)
swirl()
library(swirl)
swirl()
myplot(34)
myplot(33.3)
myplot(30)
myplot(28)
z <- qnorm(.95)
pnorm(quantile = 30+z, mean= 30, lower.tail = FALSE)
pnorm(quantile = 30 + z, mean= 30, lower.tail = FALSE)
pnorm(mean= 30, lower.tail = FALSE)
pnorm(mean= 30, lower.tail = FALSE, q = 30+z)
pnorm(mean= 32, lower.tail = FALSE, q = 30+z)
pnorm(mean= 32, sd = 1, lower.tail = FALSE, q = 30+z)
pnorm(mean= 32, sd = 2, lower.tail = FALSE, q = 30+z)
pnorm(mean= 32, sd = 2, lower.tail = FALSE, q = 30+z*2)
power.t.test(n = 16, delta = 2/4, sd = 1, type = "one.sample", alt = "one.sided")$power
power.t.test(n = 16, delta = 2, sd = 4, type = "one.sample", alt = "one.sided")$power
power.t.test(n = 16, delta = 100, sd = 200, type = "one.sample", alt = "one.sided")$power
power.t.test(pwer = .8, delta = 2/4, sd = 1, type = "one.sample", alt = "one.sided")$n
power.t.test(power = .8, delta = 2/4, sd = 1, type = "one.sample", alt = "one.sided")$n
power.t.test(power = .8, delta = 2, sd = 4, type = "one.sample", alt = "one.sided")$n
power.t.test(power = .8, delta = 100, sd = 200, type = "one.sample", alt = "one.sided")$n
power.t.test(power = .8, n = 26, sd = 200, type = "one.sample", alt = "one.sided")$delta
power.t.test(power = .8, n = 26, sd = 1, type = "one.sample", alt = "one.sided")$delta
power.t.test(power = .8, n = 27, sd = 1, type = "one.sample", alt = "one.sided")$delta
head(pvalues)
head(pValues)
sum(pValues <= .05)
sum(pValues < .05)
sum(p.adjust(pValues) < .05)
sum(p.adjust(pValues, method = "bonferroni") < .05)
sum(p.adjust(pValues, method = "BH") < .05)
tail(trueStatus)
table(pValues2 <.05, trueStatus)
.24
24/500
table(p.adjust(pValues2, "bonferroni") <.05, trueStatus)
table(p.adjust(pValues2, "BH") <.05, trueStatus)
(1/6+2/6+3/6+4/6+5/6+6/6)
print(g2)
head(sh)
nh
median(resampledMedians)
median(sh)
sam <- sample(fh, nh*B, replace = TRUE)
matrix(sam, nrow = B, ncol = nh)
resam <- matrix(sam, nrow = B, ncol = nh)
meds <- apply(resam, 1, median)
median(fh) - median(meds)
sd(meds)
sd(resampledMedians)
quantile(resampledMedians, c(.25,.75))
quantile(resampledMedians, c(.025,.975))
quantile(meds, c(.025,.975))
dim(InsectSprays)
names(InsectSprays)
range(Bdata$count)
range(Cdata$count)
BCcounts
group
testStat
testStat(BCcounts)
obs <- testStat(BCcounts, group)
obs
mean(Bdata$count - Cdata$count)
sample(group)
perms <- sapply(1 : 10000, function(i) testStat(BCcount, sample(group)))
perms <- sapply(1 : 10000, function(i) testStat(BCcounts, sample(group)))
pers>obs
mean(perms > obs)
testStat(DEcounts, group)
perms <- sapply(1:10000, function(i) testStat(DEcounts, sample(group)))
rexp(10, .2)
plot(rexp(100,.2))
hist(rexp(100,.2))
hist(runif(1000))
hist(rexp(1000,.2)
)
hist(rexp(1000,.2))
% ams
\usepackage{amssymb,amsmath}
+% utf8 encoding
+\usepackage[utf8]{inputenc}
+
% graphix
\usepackage{graphicx}
\setkeys{Gin}{width=\linewidth,totalheight=\textheight,keepaspectratio}
devtools::install_github("rstudio/rmarkdown")
library(markdown)
rmarkdown::render('in.md',
output_format=pdf_document(latex_engine='xelatex')
)
hist(rexp(1000,.2))
for (i in 1 : 1000) mns = c(mns, mean(rexp(40, .2)))
mns <- NULL
for (i in 1 : 1000) mns = c(mns, mean(rexp(40, .2)))
hist(mns)
sd(mns)
mean(mns)
se <- sd(mns)/sqrt(1000)
setwd("~/Data Science/3 Getting and Cleaning Data")
setwd("~/Data Science/3 Getting and Cleaning Data/getdata_projectfiles_UCI HAR Dataset/UCI HAR Dataset")
#Call relevant packages
library(plyr)
library(dplyr)
## Read in test data
xtest <- read.table("test/X_test.txt")
ytest <- read.table("test/y_test.txt")
subjecttest <- read.table("test/subject_test.txt")
## Combine the test data into 1 table
test <- cbind(ytest,subjecttest,xtest)
## Read in train data
xtrain <- read.table("train/X_train.txt")
ytrain <- read.table("train/y_train.txt")
subjecttrain <- read.table("train/subject_train.txt")
## Combine the train data into 1 table
train <- cbind(ytrain,subjecttrain,xtrain)
## Comine train and test data into full data set
full <- rbind(train, test)
## pull in column headers and activity headers
headers <- read.table("features.txt")
activitylabels <- read.table("activity_labels.txt")
## Rename activitylabels columns and change headers to strings
names(activitylabels) <- c("ActivityNumber", "Activity")
headers$V2 <- as.character(headers$V2)
## Rename columns based on headers
pracheaders <- c("ActivityNumber","SubjectNumber", headers$V2)
names(full) <- pracheaders
##Find and select mean/std columns
mstd <- grep("[Mm]ean\\(|[Ss][Tt][Dd]\\(",headers$V2)+2
mstd <- c(1,2,mstd)
## Pull out and re-order only relevent columns
trimmed <- full[,mstd]
final <- merge(trimmed,activitylabels)
final <- select(final, SubjectNumber, Activity,contains("mean"), contains("std"))
final <- arrange(final, SubjectNumber, Activity)
summary <- final %>%
group_by(Activity, SubjectNumber) %>%
summarise_each(funs(mean))
str(summary)
dim(summary)
dim(final)
names(final)
write(final, file = "activitydata.txt")
dim(final)
write(final, file = "activitydata.txt", ncolumns = 68)
write(final, file = "activitydata.txt", ncolumns = 68, append = TRUE, sep = " ")
?write.csv
write.table(x = final, file = "activitydata.txt")
setwd("~/GitHub/Getting and Cleaning Data")
write.table(x = final, file = "activitydata.txt")
